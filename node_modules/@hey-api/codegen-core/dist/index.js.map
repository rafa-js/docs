{"version":3,"sources":["../src/bimap/bimap.ts","../src/renderers/renderer.ts","../src/files/file.ts","../src/project/project.ts"],"names":["BiMap","key","value","wrapId","symbolId","unwrapId","wrappedId","createPlaceholderRegExp","replaceWrappedIds","source","replacerFn","match","CodegenFile","_CodegenFile","path","project","meta","filePath","exp","imp","field","existing","typeName","id","symbol","inserted","values","name","target","file","relativePath","selector","updated","CodegenProject","fileOrPath","renderer","_meta","existingFile","fileId","ids","results","index","header","content","symbols","f"],"mappings":"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","file":"index.js","sourcesContent":["import type { ICodegenBiMap } from './types';\n\nexport class BiMap<Key, Value> implements ICodegenBiMap<Key, Value> {\n  private map = new Map<Key, Value>();\n  private reverse = new Map<Value, Key>();\n\n  delete(key: Key): boolean {\n    const value = this.map.get(key);\n    if (value !== undefined) {\n      this.reverse.delete(value);\n    }\n    return this.map.delete(key);\n  }\n\n  deleteValue(value: Value): boolean {\n    const key = this.reverse.get(value);\n    if (key !== undefined) {\n      this.map.delete(key);\n    }\n    return this.reverse.delete(value);\n  }\n\n  entries(): IterableIterator<[Key, Value]> {\n    return this.map.entries();\n  }\n\n  get(key: Key): Value | undefined {\n    return this.map.get(key);\n  }\n\n  getKey(value: Value): Key | undefined {\n    return this.reverse.get(value);\n  }\n\n  hasKey(key: Key): boolean {\n    return this.map.has(key);\n  }\n\n  hasValue(value: Value): boolean {\n    return this.reverse.has(value);\n  }\n\n  keys(): IterableIterator<Key> {\n    return this.map.keys();\n  }\n\n  set(key: Key, value: Value): this {\n    this.map.set(key, value);\n    this.reverse.set(value, key);\n    return this;\n  }\n\n  get size(): number {\n    return this.map.size;\n  }\n\n  values(): IterableIterator<Value> {\n    return this.map.values();\n  }\n\n  [Symbol.iterator](): IterableIterator<[Key, Value]> {\n    return this.map[Symbol.iterator]();\n  }\n}\n","/**\n * Wraps an ID in namespace to avoid collisions when replacing it.\n *\n * @param symbolId Stringified symbol ID to use.\n * @returns The wrapped placeholder ID.\n */\nexport const wrapId = (symbolId: string): string => `_heyapi_${symbolId}_`;\n\n/**\n * Unwraps an ID from namespace.\n *\n * @param wrappedId The wrapped placeholder ID.\n * @returns Stringified ID to use.\n */\nconst unwrapId = (wrappedId: string): string =>\n  wrappedId.slice('_heyapi_'.length, -1);\n\n/**\n * Returns a RegExp instance to match ID placeholders.\n *\n * @returns RegExp instance to match ID placeholders.\n */\nconst createPlaceholderRegExp = (): RegExp => new RegExp(wrapId('\\\\d+'), 'g');\n\n/**\n *\n * @param source The source string to replace.\n * @param replacerFn Accepts a symbol ID, returns resolved symbol name.\n * @returns The replaced source string.\n */\nexport const replaceWrappedIds = (\n  source: string,\n  replacerFn: (symbolId: number) => string | undefined,\n): string =>\n  source.replace(createPlaceholderRegExp(), (match) => {\n    const symbolId = Number.parseInt(unwrapId(match), 10);\n    return replacerFn(symbolId) || match;\n  });\n","import path from 'node:path';\n\nimport { BiMap } from '../bimap/bimap';\nimport type { ICodegenBiMap } from '../bimap/types';\nimport type { ICodegenImport } from '../imports/types';\nimport type { ICodegenProject } from '../project/types';\nimport { wrapId } from '../renderers/renderer';\nimport type {\n  ICodegenSymbolIn,\n  ICodegenSymbolOut,\n  ICodegenSymbolSelector,\n} from '../symbols/types';\nimport type { ICodegenFile } from './types';\n\nexport class CodegenFile implements ICodegenFile {\n  private cache: {\n    exports?: ReadonlyArray<ICodegenImport>;\n    imports?: ReadonlyArray<ICodegenImport>;\n    symbols?: ReadonlyArray<ICodegenSymbolOut>;\n  } = {};\n\n  private renderSymbols: Array<number> = [];\n\n  private state: {\n    exports: Map<string, ICodegenImport>;\n    imports: Map<string, ICodegenImport>;\n    symbols: Map<number, ICodegenSymbolOut>;\n  } = {\n    exports: new Map(),\n    imports: new Map(),\n    symbols: new Map(),\n  };\n\n  id: number;\n  resolvedNames: ICodegenBiMap<number, string> = new BiMap();\n\n  constructor(\n    public path: string,\n    public project: ICodegenProject,\n    public meta: ICodegenFile['meta'] = {},\n  ) {\n    let filePath = CodegenFile.pathToFilePath(path);\n    if (meta.path) {\n      if (typeof meta.path === 'function') {\n        filePath = meta.path(filePath);\n      } else {\n        filePath = meta.path.replace('{{path}}', filePath);\n      }\n    }\n    this.id = project.incrementFileId();\n    this.path = filePath;\n  }\n\n  addExport(exp: ICodegenImport): void {\n    return this.addImportExport(exp, 'exports');\n  }\n\n  addImport(imp: ICodegenImport): void {\n    return this.addImportExport(imp, 'imports');\n  }\n\n  private addImportExport(\n    value: ICodegenImport,\n    field: 'exports' | 'imports',\n  ): void {\n    const key = this.getImportExportKey(value);\n    const existing = this.state[field].get(key);\n    // cast type names to names to allow for cleaner API,\n    // otherwise users would have to define the same values twice\n    if (!value.names) value.names = [];\n    for (const typeName of value.typeNames ?? []) {\n      if (!value.names.includes(typeName)) {\n        value.names = [...value.names, typeName];\n      }\n    }\n    if (existing) {\n      this.mergeImportExportValues(existing, value);\n      this.state[field].set(key, existing);\n    } else {\n      this.state[field].set(key, { ...value }); // clone to avoid mutation\n    }\n    this.cache[field] = undefined; // invalidate cache\n  }\n\n  private addRenderSymbol(id: number): void {\n    this.renderSymbols.push(id);\n    this.cache.symbols = undefined; // invalidate cache\n  }\n\n  addSymbol(symbol: ICodegenSymbolIn): ICodegenSymbolOut {\n    const id = this.project.incrementSymbolId();\n    const inserted: ICodegenSymbolOut = {\n      ...symbol, // clone to avoid mutation\n      file: this,\n      id,\n      placeholder: wrapId(String(id)),\n      update: (values) => this.updateSymbol(id, values),\n    };\n    if (inserted.value === undefined) {\n      // register symbols without value as headless\n      inserted.headless = true;\n    } else if (!inserted.headless) {\n      delete inserted.headless;\n    }\n    this.state.symbols.set(id, inserted);\n    this.project.registerSymbol(inserted, this);\n    if (!inserted.headless) {\n      this.addRenderSymbol(id);\n    }\n    return inserted;\n  }\n\n  ensureSymbol(\n    symbol: Partial<ICodegenSymbolIn> &\n      Pick<Required<ICodegenSymbolIn>, 'selector'>,\n  ): ICodegenSymbolOut {\n    return (\n      this.selectSymbolFirst(symbol.selector) ||\n      this.addSymbol({ name: '', ...symbol })\n    );\n  }\n\n  get exports(): ReadonlyArray<ICodegenImport> {\n    if (!this.cache.exports) {\n      this.cache.exports = Array.from(this.state.exports.values());\n    }\n    return this.cache.exports;\n  }\n\n  getAllSymbols(): ReadonlyArray<Pick<ICodegenSymbolOut, 'name'>> {\n    return [\n      ...this.symbols,\n      ...this.imports.flatMap((imp) =>\n        (imp.names ?? []).map((name) => ({\n          name: imp.aliases?.[name] ?? name,\n        })),\n      ),\n      ...this.exports.flatMap((imp) =>\n        (imp.names ?? []).map((name) => ({\n          name: imp.aliases?.[name] ?? name,\n        })),\n      ),\n    ];\n  }\n\n  private getImportExportKey(value: ICodegenImport): string {\n    if (typeof value.from === 'string') {\n      return value.from;\n    }\n    return value.from.path;\n  }\n\n  getSymbolById(id: number): ICodegenSymbolOut | undefined {\n    return this.state.symbols.get(id);\n  }\n\n  hasContent(): boolean {\n    return this.state.exports.size > 0 || this.symbols.length > 0;\n  }\n\n  hasSymbol(id: number): boolean {\n    return this.state.symbols.has(id);\n  }\n\n  get imports(): ReadonlyArray<ICodegenImport> {\n    if (!this.cache.imports) {\n      this.cache.imports = Array.from(this.state.imports.values());\n    }\n    return this.cache.imports;\n  }\n\n  private mergeImportExportValues(\n    target: ICodegenImport,\n    source: ICodegenImport,\n  ): void {\n    target.aliases = { ...target.aliases, ...source.aliases };\n    if (source.defaultImport !== undefined) {\n      target.defaultImport = source.defaultImport;\n    }\n    target.names = [\n      ...new Set([...(target.names ?? []), ...(source.names ?? [])]),\n    ];\n    if (source.namespaceImport !== undefined) {\n      target.namespaceImport = source.namespaceImport;\n    }\n    if (source.typeDefaultImport !== undefined) {\n      target.typeDefaultImport = source.typeDefaultImport;\n    }\n    target.typeNames = [\n      ...new Set([...(target.typeNames ?? []), ...(source.typeNames ?? [])]),\n    ];\n    if (source.typeNamespaceImport !== undefined) {\n      target.typeNamespaceImport = source.typeNamespaceImport;\n    }\n  }\n\n  static pathToFilePath(source: string): string {\n    if (source.includes('/')) {\n      return source.split('/').filter(Boolean).join(path.sep);\n    }\n    if (source.includes('\\\\')) {\n      return source.split('\\\\').filter(Boolean).join(path.sep);\n    }\n    return source.split(path.sep).filter(Boolean).join(path.sep);\n  }\n\n  relativePathFromFile(file: Pick<ICodegenFile, 'path'>): string {\n    let relativePath = path.posix.relative(\n      path.posix.dirname(file.path),\n      this.path,\n    );\n    if (!relativePath.startsWith('.')) {\n      relativePath = `./${relativePath}`;\n    }\n    return relativePath;\n  }\n\n  relativePathToFile(file: Pick<ICodegenFile, 'path'>): string {\n    let relativePath = path.posix.relative(\n      path.posix.dirname(\n        this.path.split(path.sep).join('/'), // normalize to posix\n      ),\n      file.path.split(path.sep).join('/'), // normalize to posix\n    );\n    if (!relativePath.startsWith('.') && relativePath !== '') {\n      relativePath = `./${relativePath}`;\n    }\n    return relativePath;\n  }\n\n  selectSymbolAll(\n    selector: ICodegenSymbolSelector,\n  ): ReadonlyArray<ICodegenSymbolOut> {\n    return this.project.selectSymbolAll(selector, this);\n  }\n\n  selectSymbolFirst(\n    selector: ICodegenSymbolSelector,\n  ): ICodegenSymbolOut | undefined {\n    return this.project.selectSymbolFirst(selector, this);\n  }\n\n  selectSymbolFirstOrThrow(\n    selector: ICodegenSymbolSelector,\n  ): ICodegenSymbolOut {\n    return this.project.selectSymbolFirstOrThrow(selector, this);\n  }\n\n  selectSymbolLast(\n    selector: ICodegenSymbolSelector,\n  ): ICodegenSymbolOut | undefined {\n    return this.project.selectSymbolLast(selector, this);\n  }\n\n  get symbols(): ReadonlyArray<ICodegenSymbolOut> {\n    if (!this.cache.symbols) {\n      this.cache.symbols = this.renderSymbols.map(\n        (id) => this.getSymbolById(id)!,\n      );\n    }\n    return this.cache.symbols;\n  }\n\n  updateSymbol(\n    id: number,\n    symbol: Partial<ICodegenSymbolOut>,\n  ): ICodegenSymbolOut {\n    const existing = this.getSymbolById(id);\n    if (!existing) {\n      throw new Error(`symbol with id ${id} not found`);\n    }\n    const updated: ICodegenSymbolOut = { ...existing, ...symbol, id };\n    // symbols with value can't be headless, clear redundant flag otherwise\n    if (!updated.headless || updated.value) {\n      delete updated.headless;\n    }\n    this.state.symbols.set(updated.id, updated);\n    if (existing.headless && !updated.headless) {\n      this.addRenderSymbol(id);\n    }\n    return updated;\n  }\n}\n","import { CodegenFile } from '../files/file';\nimport type { ICodegenFile } from '../files/types';\nimport type { ICodegenImport } from '../imports/types';\nimport type { ICodegenMeta } from '../meta/types';\nimport type { ICodegenOutput } from '../output/types';\nimport { replaceWrappedIds } from '../renderers/renderer';\nimport type { ICodegenRenderer } from '../renderers/types';\nimport type {\n  ICodegenSymbolIn,\n  ICodegenSymbolOut,\n  ICodegenSymbolSelector,\n} from '../symbols/types';\nimport type { ICodegenProject } from './types';\n\nexport class CodegenProject implements ICodegenProject {\n  private fileId: number = 0;\n  private fileIdToFile: Map<number, ICodegenFile> = new Map();\n  private fileOrder: Array<ICodegenFile> = [];\n  private filePathToFileId: Map<string, number> = new Map();\n  private renderers: Map<string, ICodegenRenderer> = new Map();\n  private selectorToSymbolIds: Map<string, Array<number>> = new Map();\n  private symbolId: number = 0;\n  private symbolIdToFileId: Map<number, number> = new Map();\n\n  addExport(fileOrPath: ICodegenFile | string, imp: ICodegenImport): void {\n    const file = this.ensureFile(fileOrPath);\n    file.addExport(imp);\n  }\n\n  addImport(fileOrPath: ICodegenFile | string, imp: ICodegenImport): void {\n    const file = this.ensureFile(fileOrPath);\n    file.addImport(imp);\n  }\n\n  addSymbol(\n    fileOrPath: ICodegenFile | string,\n    symbol: ICodegenSymbolIn,\n  ): ICodegenSymbolOut {\n    const file = this.ensureFile(fileOrPath);\n    return file.addSymbol(symbol);\n  }\n\n  createFile(\n    path: string,\n    meta: Omit<ICodegenFile['meta'], 'renderer'> & {\n      /**\n       * Renderer to use to render this file.\n       */\n      renderer?: ICodegenRenderer;\n    } = {},\n  ): ICodegenFile {\n    const { renderer, ..._meta } = meta;\n    if (renderer) {\n      this.ensureRenderer(renderer);\n    }\n\n    const existing = this.getFileByPath(path);\n    if (existing) {\n      // Whoever is creating the file will override the renderer\n      if (renderer?.id && renderer.id !== existing.meta.renderer) {\n        existing.meta.renderer = renderer.id;\n      }\n      return existing;\n    }\n\n    const file = new CodegenFile(path, this, {\n      ..._meta,\n      renderer: renderer?.id,\n    });\n    this.fileOrder.push(file);\n    this.filePathToFileId.set(path, file.id);\n    this.fileIdToFile.set(file.id, file);\n    return file;\n  }\n\n  ensureFile(fileOrPath: ICodegenFile | string): ICodegenFile {\n    if (typeof fileOrPath !== 'string') {\n      return fileOrPath;\n    }\n    const existingFile = this.getFileByPath(fileOrPath);\n    if (existingFile) {\n      return existingFile;\n    }\n    return this.createFile(fileOrPath);\n  }\n\n  private ensureRenderer(renderer: ICodegenRenderer): ICodegenRenderer {\n    if (!this.renderers.has(renderer.id)) {\n      this.renderers.set(renderer.id, renderer);\n    }\n    return this.renderers.get(renderer.id)!;\n  }\n\n  get files(): ReadonlyArray<ICodegenFile> {\n    return [...this.fileOrder];\n  }\n\n  getAllSymbols(): ReadonlyArray<Pick<ICodegenSymbolOut, 'name'>> {\n    return this.fileOrder.flatMap((file) => file.getAllSymbols());\n  }\n\n  getFileByPath(path: string): ICodegenFile | undefined {\n    const fileId = this.filePathToFileId.get(path);\n    return fileId !== undefined ? this.fileIdToFile.get(fileId) : undefined;\n  }\n\n  getFileBySymbolId(id: number): ICodegenFile | undefined {\n    const fileId = this.symbolIdToFileId.get(id);\n    return fileId !== undefined ? this.fileIdToFile.get(fileId) : undefined;\n  }\n\n  private getFileRenderer(file: ICodegenFile): ICodegenRenderer | undefined {\n    return file.meta.renderer\n      ? this.renderers.get(file.meta.renderer)\n      : undefined;\n  }\n\n  getSymbolById(id: number): ICodegenSymbolOut | undefined {\n    const file = this.getFileBySymbolId(id);\n    return file?.getSymbolById(id);\n  }\n\n  incrementFileId(): number {\n    return this.fileId++;\n  }\n\n  incrementSymbolId(): number {\n    return this.symbolId++;\n  }\n\n  registerSymbol(symbol: ICodegenSymbolOut, file: ICodegenFile): void {\n    this.symbolIdToFileId.set(symbol.id, file.id);\n    if (symbol.selector) {\n      const selector = JSON.stringify(symbol.selector);\n      const ids = this.selectorToSymbolIds.get(selector) ?? [];\n      ids.push(symbol.id);\n      this.selectorToSymbolIds.set(selector, ids);\n    }\n  }\n\n  render(meta?: ICodegenMeta): ReadonlyArray<ICodegenOutput> {\n    const results: Array<ICodegenOutput> = [];\n    this.fileOrder.forEach((file, index) => {\n      const renderer = this.getFileRenderer(file);\n      if (!renderer) return;\n      results[index] = {\n        content: renderer.renderSymbols(file, meta),\n        meta: file.meta,\n        path: `${file.path}${file.meta.extension ?? ''}`,\n      };\n    });\n    this.fileOrder.forEach((file, index) => {\n      const renderer = this.getFileRenderer(file);\n      if (!renderer || !results[index]) return;\n      const header = renderer.renderHeader(file, meta);\n      const content = replaceWrappedIds(results[index].content, (symbolId) =>\n        renderer.replacerFn({ file, symbolId }),\n      );\n      results[index].content = `${header}${content}`;\n    });\n    return results.filter(Boolean);\n  }\n\n  selectSymbolAll(\n    selector: ICodegenSymbolSelector,\n    file?: ICodegenFile,\n  ): ReadonlyArray<ICodegenSymbolOut> {\n    const ids = this.selectorToSymbolIds.get(JSON.stringify(selector)) ?? [];\n    const symbols: Array<ICodegenSymbolOut> = [];\n    for (const id of ids) {\n      const f = this.getFileBySymbolId(id);\n      if (!f || (file && file !== f)) continue;\n      const symbol = f.getSymbolById(id);\n      if (!symbol) continue;\n      symbols.push(symbol);\n    }\n    return symbols;\n  }\n\n  selectSymbolFirst(\n    selector: ICodegenSymbolSelector,\n    file?: ICodegenFile,\n  ): ICodegenSymbolOut | undefined {\n    const symbols = this.selectSymbolAll(selector, file);\n    return symbols[0];\n  }\n\n  selectSymbolFirstOrThrow(\n    selector: ICodegenSymbolSelector,\n    file?: ICodegenFile,\n  ): ICodegenSymbolOut {\n    const symbol = this.selectSymbolFirst(selector, file);\n    if (!symbol)\n      throw new Error(\n        `symbol for selector not found: ${JSON.stringify(selector)}`,\n      );\n    return symbol;\n  }\n\n  selectSymbolLast(\n    selector: ICodegenSymbolSelector,\n    file?: ICodegenFile,\n  ): ICodegenSymbolOut | undefined {\n    const symbols = this.selectSymbolAll(selector, file);\n    return symbols[symbols.length - 1];\n  }\n}\n"]}