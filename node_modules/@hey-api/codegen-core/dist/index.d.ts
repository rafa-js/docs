/**
 * Bi-directional map interface.
 *
 * Keys map to values and values map back to keys.
 *
 * @template Key Type of the map keys
 * @template Value Type of the map values
 */
interface ICodegenBiMap<Key, Value> {
  /**
   * Deletes a key and its associated value from the map.
   *
   * @param key The key to delete.
   */
  delete(key: Key): boolean;
  /**
   * Deletes a value and its associated key from the map.
   *
   * @param value The value to delete.
   */
  deleteValue(value: Value): boolean;
  /**
   * Returns an iterator of [key, value] pairs.
   */
  entries(): IterableIterator<[Key, Value]>;
  /**
   * Gets the value associated with a key.
   *
   * @param key The key to look up.
   */
  get(key: Key): Value | undefined;
  /**
   * Gets the key associated with a value.
   *
   * @param value The value to look up.
   */
  getKey(value: Value): Key | undefined;
  /**
   * Checks if a key exists in the map.
   *
   * @param key The key to check.
   */
  hasKey(key: Key): boolean;
  /**
   * Checks if a value exists in the map.
   *
   * @param value The value to check.
   */
  hasValue(value: Value): boolean;
  /**
   * Returns an iterator of keys.
   */
  keys(): IterableIterator<Key>;
  /**
   * Sets a key-value pair in the map.
   *
   * @param key The key.
   * @param value The value.
   * @returns This instance for chaining.
   */
  set(key: Key, value: Value): this;
  /**
   * Number of key-value pairs in the map.
   */
  readonly size: number;
  /**
   * Returns an iterator of values.
   */
  values(): IterableIterator<Value>;
  /**
   * Enables iteration with `for...of`.
   */
  [Symbol.iterator](): IterableIterator<[Key, Value]>;
}

declare class BiMap<Key, Value> implements ICodegenBiMap<Key, Value> {
    private map;
    private reverse;
    delete(key: Key): boolean;
    deleteValue(value: Value): boolean;
    entries(): IterableIterator<[Key, Value]>;
    get(key: Key): Value | undefined;
    getKey(value: Value): Key | undefined;
    hasKey(key: Key): boolean;
    hasValue(value: Value): boolean;
    keys(): IterableIterator<Key>;
    set(key: Key, value: Value): this;
    get size(): number;
    values(): IterableIterator<Value>;
    [Symbol.iterator](): IterableIterator<[Key, Value]>;
}

/**
 * Arbitrary metadata passed to render functions.
 *
 * Implementors should extend this interface for their own needs.
 */
interface ICodegenMeta {
  [key: string]: unknown;
}

interface ICodegenOutput {
  /**
   * The main content of the file to output.
   *
   * A raw string representing source code.
   *
   * @example "function foo(): void {\n  // implementation\n}\n"
   */
  content: string;
  /**
   * Optional metadata or hints for the emitter, such as formatting options,
   * source maps, or language-specific flags.
   *
   * @example { format: "prettier", sourceMap: true }
   */
  meta: Record<string, unknown>;
  /**
   * Logical output path (used for writing the file).
   *
   * @example "models/user.ts"
   */
  path: string;
}

interface ICodegenRenderer {
  /**
   * Optional: hook for renderer-level setup logic (e.g., formatting, config)
   */
  configure?(options: Record<string, unknown>): void;
  /**
   * Unique identifier for this renderer.
   *
   * @example "typescript"
   */
  id: string;
  /**
   * Returns printable data containing header and imports.
   *
   * @param file The file to render.
   * @param meta Arbitrary metadata.
   * @returns Printable string containing header and imports.
   */
  renderHeader(file: ICodegenFile, meta?: ICodegenMeta): string;
  /**
   * Returns printable data containing symbols and exports.
   *
   * @param file The file to render.
   * @param meta Arbitrary metadata.
   * @returns Printable string containing symbols and exports.
   */
  renderSymbols(file: ICodegenFile, meta?: ICodegenMeta): string;
  /**
   * Function replacing symbols with resolved names.
   *
   * @returns String with replaced symbols.
   */
  replacerFn(args: {
    file: ICodegenFile;
    headless?: boolean;
    scope?: 'file' | 'project';
    symbolId: number;
  }): string | undefined;
}

/**
 * Selector array used to select symbols. It doesn't have to be
 * unique, but in practice it might be desirable.
 *
 * @example ["zod", "#/components/schemas/Foo"]
 */
type ICodegenSymbolSelector = ReadonlyArray<string>;

interface ICodegenSymbolIn {
  /**
   * Symbols can be **headed** or **headless**.
   *
   * Headless symbols never render their `value`. Headed symbols render their
   * `value` if defined.
   *
   * Symbols are rendered in the order they were registered as headed.
   *
   * Example 1: We register headless symbol `foo`, headed `bar`, and headed
   * `foo`. The render order is [`bar`, `foo`].
   *
   * Example 2: We register headed symbol `foo` and headed `bar`. The render
   * order is [`foo`, `bar`].
   *
   * Headless symbols can be used to claim a symbol or to represent imports
   * or exports.
   *
   * @default false
   */
  headless?: boolean;
  /**
   * The desired name for the symbol within its file. If there are multiple symbols
   * with the same desired name, this might not end up being the actual name.
   *
   * @example "UserModel"
   */
  readonly name: string;
  /**
   * Selector array used to select this symbol. It doesn't have to be
   * unique, but in practice it might be desirable.
   *
   * @example ["zod", "#/components/schemas/Foo"]
   */
  readonly selector?: ICodegenSymbolSelector;
  /**
   * Internal representation of the symbol (e.g. AST node, IR object, raw code).
   * Used to generate output. If left undefined, this symbol becomes `headless`.
   */
  readonly value?: unknown;
}

interface ICodegenSymbolOut extends ICodegenSymbolIn {
  /**
   * The file this symbol is located in.
   */
  readonly file: ICodegenFile;
  /**
   * Unique symbol ID.
   */
  readonly id: number;
  /**
   * Placeholder name for the symbol to be replaced later with the final value.
   *
   * @example "_heyapi_31_"
   */
  readonly placeholder: string;
  /**
   * Updates this symbol.
   *
   * @param symbol The values to update.
   * @returns The updated symbol.
   */
  readonly update: (symbol: Partial<ICodegenSymbolOut>) => ICodegenSymbolOut;
}

interface SelectorMethods {
  /**
   * Retrieves symbols matching the selector.
   *
   * @param selector The symbol selector to find.
   * @param file Find symbols only in this file.
   * @returns The array of all symbols matching the selector.
   * @example
   * const symbols = project.selectSymbolAll(["zod", "#/components/schemas/Foo"]);
   */
  selectSymbolAll(
    selector: ICodegenSymbolSelector,
    file?: ICodegenFile,
  ): ReadonlyArray<ICodegenSymbolOut>;
  /**
   * Retrieves the first symbol from all symbols matching the selector.
   *
   * @param selector The symbol selector to find.
   * @param file Find symbols only in this file.
   * @returns The symbol if found, or undefined otherwise.
   * @example
   * const symbol = project.selectSymbolFirst(["zod", "#/components/schemas/Foo"]);
   */
  selectSymbolFirst(
    selector: ICodegenSymbolSelector,
    file?: ICodegenFile,
  ): ICodegenSymbolOut | undefined;
  /**
   * Retrieves the first symbol from all symbols matching the selector.
   *
   * @param selector The symbol selector to find.
   * @param file Find symbols only in this file.
   * @returns The symbol if found, or throw otherwise.
   * @example
   * const symbol = project.selectSymbolFirstOrThrow(["zod", "#/components/schemas/Foo"]);
   */
  selectSymbolFirstOrThrow(
    selector: ICodegenSymbolSelector,
    file?: ICodegenFile,
  ): ICodegenSymbolOut;
  /**
   * Retrieves the last symbol from all symbols matching the selector.
   *
   * @param selector The symbol selector to find.
   * @param file Find symbols only in this file.
   * @returns The symbol if found, or undefined otherwise.
   * @example
   * const symbol = project.selectSymbolLast(["zod", "#/components/schemas/Foo"]);
   */
  selectSymbolLast(
    selector: ICodegenSymbolSelector,
    file?: ICodegenFile,
  ): ICodegenSymbolOut | undefined;
}

/**
 * Represents a code generation project consisting of multiple codegen files.
 * Manages imports, symbols, and output generation across the project.
 */
interface ICodegenProject extends SelectorMethods {
  /**
   * Adds an export declaration to a specific file, creating the file if it doesn't exist.
   *
   * @param fileOrPath - File instance or file path where to add the export.
   * @param imp - The export declaration to add.
   * @example
   * project.addExport("models/user.ts", { from: "lib", names: ["User"] });
   */
  addExport(fileOrPath: ICodegenFile | string, imp: ICodegenImport): void;
  /**
   * Adds an import declaration to a specific file, creating the file if it doesn't exist.
   *
   * @param fileOrPath - File instance or file path where to add the import.
   * @param imp - The import declaration to add.
   * @example
   * project.addImport("models/user.ts", { from: "lib", names: ["User"] });
   */
  addImport(fileOrPath: ICodegenFile | string, imp: ICodegenImport): void;
  /**
   * Adds a symbol to a specific file, creating the file if it doesn't exist.
   *
   * @param fileOrPath - File instance or file path where to add the symbol.
   * @param symbol - The symbol to add.
   * @returns The inserted symbol.
   * @example
   * project.addSymbol("models/user.ts", { name: "User", value: tsNode });
   */
  addSymbol(
    fileOrPath: ICodegenFile | string,
    symbol: ICodegenSymbolIn,
  ): ICodegenSymbolOut;
  /**
   * Creates a new codegen file with optional metadata and adds it to the project.
   *
   * If a file with the same path already exists, it is returned instead.
   *
   * @param path - The logical output path for the file (e.g. "models/user.ts").
   * @param meta - Optional renderer and metadata to attach to the file (e.g. { isInternal: true }).
   * @returns The newly created file instance.
   * @example
   * const file = project.createFile("models/user.ts", { isInternal: true });
   */
  createFile(
    path: string,
    meta?: ICodegenFile['meta'] & { renderer?: ICodegenRenderer },
  ): ICodegenFile;
  /**
   * Ensures a codegen file exists and returns it.
   *
   * If a file does not exist yet, it is created with minimal information.
   * Later, it is expected `createFile()` will be called which will fill in
   * the missing information such as optional metadata.
   *
   * @param fileOrPath - The logical output path for the file or the file itself.
   * @returns The file instance.
   * @example
   * const file = project.ensureFile("models/user.ts");
   */
  ensureFile(fileOrPath: ICodegenFile | string): ICodegenFile;
  /**
   * Returns all files in the project in insertion order.
   *
   * @example
   * project.files.forEach(file => console.log(file.path));
   */
  readonly files: ReadonlyArray<ICodegenFile>;
  /**
   * Returns all symbols declared or imported across all files.
   *
   * @returns Flattened list of all codegen symbols.
   * @example
   * project.getAllSymbols().filter(s => s.name === "User");
   */
  getAllSymbols(): ReadonlyArray<Pick<ICodegenSymbolOut, 'name'>>;
  /**
   * Retrieves a file by its logical output path.
   *
   * @param path - The file path to find.
   * @returns The file if found, or undefined otherwise.
   * @example
   * const file = project.getFileByPath("models/user.ts");
   */
  getFileByPath(path: string): ICodegenFile | undefined;
  /**
   * Retrieves a file from symbol ID included in the file.
   *
   * @param id The symbol ID to find.
   * @returns The file if found, undefined otherwise.
   * @example
   * const file = project.getFileBySymbolId(31);
   */
  getFileBySymbolId(id: number): ICodegenFile | undefined;
  /**
   * Retrieves a symbol from ID included in the project.
   *
   * @param id The symbol ID to find.
   * @returns The symbol if found, undefined otherwise.
   * @example
   * const symbol = project.getSymbolById(31);
   */
  getSymbolById(id: number): ICodegenSymbolOut | undefined;
  /**
   * Returns the current file ID and increments it.
   *
   * @returns File ID before being incremented
   */
  incrementFileId(): number;
  /**
   * Returns the current symbol ID and increments it.
   *
   * @returns Symbol ID before being incremented
   */
  incrementSymbolId(): number;
  /**
   * Tracks added symbol across the project.
   *
   * @param symbol The symbol added to file.
   * @param file The file containing the added symbol.
   */
  registerSymbol(symbol: ICodegenSymbolOut, file: ICodegenFile): void;
  /**
   * Produces output representations for all files in the project.
   *
   * @param meta Arbitrary metadata.
   * @returns Array of outputs ready for writing or further processing.
   * @example
   * project.render().forEach(output => writeFile(output));
   */
  render(meta?: ICodegenMeta): ReadonlyArray<ICodegenOutput>;
}

interface ICodegenFile extends SelectorMethods {
  /**
   * Adds an export to this file.
   *
   * This is also known as a re-export.
   *
   * @param exp The export to add
   */
  addExport(exp: ICodegenImport): void;
  /**
   * Adds an import to this file.
   *
   * @param imp The import to add
   */
  addImport(imp: ICodegenImport): void;
  /**
   * Adds a symbol defined by this file.
   *
   * @param symbol The symbol to add
   */
  addSymbol(symbol: ICodegenSymbolIn): ICodegenSymbolOut;
  /**
   * Ensures a symbol for the given selector exists, so it can be
   * safely used.
   *
   * @param symbol The symbol to find. The required selector is used
   *  to match a symbol. If there's no match, we create a headless
   *  instance with the provided fields.
   * @returns The symbol if it exists, headless instance otherwise.
   */
  ensureSymbol(
    symbol: Partial<ICodegenSymbolIn> &
      Pick<Required<ICodegenSymbolIn>, 'selector'>,
  ): ICodegenSymbolOut;
  /**
   * Symbols exported from other files.
   **/
  exports: ReadonlyArray<ICodegenImport>;
  /**
   * Returns all symbols used in this file (declared + imported).
   *
   * @returns List of all symbols used in this file
   */
  getAllSymbols(): ReadonlyArray<Pick<ICodegenSymbolOut, 'name'>>;
  /**
   * Finds a symbol by symbol ID.
   *
   * @param id Symbol ID
   * @returns The symbol if it exists, undefined otherwise.
   */
  getSymbolById(id: number): ICodegenSymbolOut | undefined;
  /**
   * Checks if this file contains any content.
   *
   * This is used to determine whether we want to process the file further.
   * By default, we consider only symbols and exports as content.
   *
   * @returns True if the file contains content
   */
  hasContent(): boolean;
  /**
   * Checks if this file defines a symbol with the given name.
   *
   * @param id Symbol ID to check
   * @returns True if the symbol is defined by this file
   */
  hasSymbol(id: number): boolean;
  /**
   * File ID within the project.
   */
  id: number;
  /**
   * Symbols imported from other files.
   **/
  imports: ReadonlyArray<ICodegenImport>;
  /**
   * Optional metadata about the file.
   **/
  meta: {
    /**
     * Optional file extension.
     *
     * @example ".ts"
     */
    extension?: '.ts' | (string & {});
    /**
     * Optional logical module or package name.
     *
     * @example "models.user"
     */
    moduleName?: string;
    /**
     * Optional path transformer.
     *
     * @param path Original file path passed to the constructor.
     */
    path?: ((path: string) => string) | string;
    /**
     * Renderer ID.
     *
     * @example "typescript"
     */
    renderer?: ICodegenRenderer['id'];
  };
  /**
   * Logical output path (used for writing the file).
   *
   * @example "models/user.ts"
   */
  path: string;
  /**
   * Parent project this file belongs to.
   */
  project: ICodegenProject;
  /**
   * Returns a relative path to this file from another file.
   *
   * @param file The file from which we want the relative path to this file.
   * @example "./this-file.ts"
   */
  relativePathFromFile(file: Pick<ICodegenFile, 'path'>): string;
  /**
   * Returns a relative path to file from this file.
   *
   * @param file The file to which we want the relative path.
   * @example "./another-file.ts"
   */
  relativePathToFile(file: Pick<ICodegenFile, 'path'>): string;
  /**
   * Map holding resolved names for symbols in this file.
   */
  resolvedNames: ICodegenBiMap<number, string>;
  /**
   * Top-level symbols declared in this file.
   **/
  symbols: ReadonlyArray<ICodegenSymbolOut>;
  /**
   * Updates a symbol defined by this file.
   *
   * @param id ID of symbol to update.
   * @param symbol The values to update.
   * @returns The updated symbol.
   */
  updateSymbol(
    id: number,
    symbol: Partial<ICodegenSymbolOut>,
  ): ICodegenSymbolOut;
}

interface ICodegenImport {
  /**
   * Optional aliasing map for imported symbols.
   *
   * Keys must be a subset of `names`, values are aliases.
   *
   * @example { User: "ImportedUser" }
   */
  aliases?: Record<string, string>;
  /**
   * Name of the default import, if any.
   *
   * @example "React"
   */
  defaultImport?: string;
  /**
   * Source file or external module from which symbols are imported.
   *
   * For internal files, this should be a ICodegenFile instance to enable
   * dynamic path computation. For external or system modules, use a string.
   *
   * @example "./models/user"
   * @example "node:path"
   */
  from: ICodegenFile | string;
  /**
   * Names of the symbols imported from the source.
   *
   * Must be non-empty unless `isNamespaceImport` is true.
   * All imported names, regardless of whether they are used as types or values.
   *
   * @example ["User", "UserDTO"]
   */
  names?: ReadonlyArray<string>;
  /**
   * If this import is a namespace import (e.g. `import * as ns from "..."`),
   * this should be the namespace alias. Set to `true` if no alias is needed.
   *
   * @example "utils"
   * @example true
   */
  namespaceImport?: boolean | string;
  /**
   * Whether the default import is type-only.
   *
   * @example true
   */
  typeDefaultImport?: boolean;
  /**
   * Subset of `names` that are imported using the `type` modifier.
   * These symbols will be emitted as type-only imports in TypeScript.
   *
   * @example ["UserDTO"]
   */
  typeNames?: ReadonlyArray<string>;
  /**
   * Whether the namespace import is type-only.
   *
   * @example true
   */
  typeNamespaceImport?: boolean;
}

declare class CodegenFile implements ICodegenFile {
    path: string;
    project: ICodegenProject;
    meta: ICodegenFile['meta'];
    private cache;
    private renderSymbols;
    private state;
    id: number;
    resolvedNames: ICodegenBiMap<number, string>;
    constructor(path: string, project: ICodegenProject, meta?: ICodegenFile['meta']);
    addExport(exp: ICodegenImport): void;
    addImport(imp: ICodegenImport): void;
    private addImportExport;
    private addRenderSymbol;
    addSymbol(symbol: ICodegenSymbolIn): ICodegenSymbolOut;
    ensureSymbol(symbol: Partial<ICodegenSymbolIn> & Pick<Required<ICodegenSymbolIn>, 'selector'>): ICodegenSymbolOut;
    get exports(): ReadonlyArray<ICodegenImport>;
    getAllSymbols(): ReadonlyArray<Pick<ICodegenSymbolOut, 'name'>>;
    private getImportExportKey;
    getSymbolById(id: number): ICodegenSymbolOut | undefined;
    hasContent(): boolean;
    hasSymbol(id: number): boolean;
    get imports(): ReadonlyArray<ICodegenImport>;
    private mergeImportExportValues;
    static pathToFilePath(source: string): string;
    relativePathFromFile(file: Pick<ICodegenFile, 'path'>): string;
    relativePathToFile(file: Pick<ICodegenFile, 'path'>): string;
    selectSymbolAll(selector: ICodegenSymbolSelector): ReadonlyArray<ICodegenSymbolOut>;
    selectSymbolFirst(selector: ICodegenSymbolSelector): ICodegenSymbolOut | undefined;
    selectSymbolFirstOrThrow(selector: ICodegenSymbolSelector): ICodegenSymbolOut;
    selectSymbolLast(selector: ICodegenSymbolSelector): ICodegenSymbolOut | undefined;
    get symbols(): ReadonlyArray<ICodegenSymbolOut>;
    updateSymbol(id: number, symbol: Partial<ICodegenSymbolOut>): ICodegenSymbolOut;
}

declare class CodegenProject implements ICodegenProject {
    private fileId;
    private fileIdToFile;
    private fileOrder;
    private filePathToFileId;
    private renderers;
    private selectorToSymbolIds;
    private symbolId;
    private symbolIdToFileId;
    addExport(fileOrPath: ICodegenFile | string, imp: ICodegenImport): void;
    addImport(fileOrPath: ICodegenFile | string, imp: ICodegenImport): void;
    addSymbol(fileOrPath: ICodegenFile | string, symbol: ICodegenSymbolIn): ICodegenSymbolOut;
    createFile(path: string, meta?: Omit<ICodegenFile['meta'], 'renderer'> & {
        /**
         * Renderer to use to render this file.
         */
        renderer?: ICodegenRenderer;
    }): ICodegenFile;
    ensureFile(fileOrPath: ICodegenFile | string): ICodegenFile;
    private ensureRenderer;
    get files(): ReadonlyArray<ICodegenFile>;
    getAllSymbols(): ReadonlyArray<Pick<ICodegenSymbolOut, 'name'>>;
    getFileByPath(path: string): ICodegenFile | undefined;
    getFileBySymbolId(id: number): ICodegenFile | undefined;
    private getFileRenderer;
    getSymbolById(id: number): ICodegenSymbolOut | undefined;
    incrementFileId(): number;
    incrementSymbolId(): number;
    registerSymbol(symbol: ICodegenSymbolOut, file: ICodegenFile): void;
    render(meta?: ICodegenMeta): ReadonlyArray<ICodegenOutput>;
    selectSymbolAll(selector: ICodegenSymbolSelector, file?: ICodegenFile): ReadonlyArray<ICodegenSymbolOut>;
    selectSymbolFirst(selector: ICodegenSymbolSelector, file?: ICodegenFile): ICodegenSymbolOut | undefined;
    selectSymbolFirstOrThrow(selector: ICodegenSymbolSelector, file?: ICodegenFile): ICodegenSymbolOut;
    selectSymbolLast(selector: ICodegenSymbolSelector, file?: ICodegenFile): ICodegenSymbolOut | undefined;
}

/**
 *
 * @param source The source string to replace.
 * @param replacerFn Accepts a symbol ID, returns resolved symbol name.
 * @returns The replaced source string.
 */
declare const replaceWrappedIds: (source: string, replacerFn: (symbolId: number) => string | undefined) => string;

export { BiMap, CodegenFile, CodegenProject, type ICodegenBiMap, type ICodegenFile, type ICodegenImport, type ICodegenMeta, type ICodegenOutput, type ICodegenProject, type ICodegenRenderer, type ICodegenSymbolIn, type ICodegenSymbolOut, type ICodegenSymbolSelector, replaceWrappedIds };
